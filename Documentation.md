# Global Commands

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `destroy` | `instance`: `UUID` | Success or failure message | `"ArmaCOM" callExtension ["destroy", [instance]];` | Destroys an instance of a communication method if it is not currently connected |

# Communication Method: Serial

This communication method is an interface for serial/COM ports. Serial ports are different from most other (read: modern) methods of communicating with computers. The main reason this is included is for use with small board computers like Arduinos and Raspberry Pis, but may be useful for other, typically legacy, hardware. Users of legacy or uncommon hardware should beware that serial communication is finnicky even in the most favorable conditions, and this has only been tested thus far with modern equipment. An important note is that due to the limitations of the technology, only **one** instance of this communication method may exist per COM port. If you attempt to create a second instance for a serial port that already has an instance, the extension will simply return the existing instance. This functionality may be useful since you can regain a port's UUID if you lost it by attempting to create a new instance, but is more likely to be a source of headaches. The extension exposes a large number of low-level parameters through getters and setters in the hope that it will be useful to users with nonstandard or legacy hardware. If you're using modern "happy" hardware like an Arduino, or don't know what any of it means, there's a very good chance the defaults will work fine. The only parameters most users will need to touch are baud rate, whether writes are threaded, and when the extension sends data back to Arma. Threaded writes are off by default just because I haven't tested their stability thoroughly, but you should turn threaded writes on unless you have issues. Despite modern hardware being incredibly fast, serial communications defaults to the snail-like 9600 baud, and even at high baud rates the overhead of writes puts a lower bound of rougly **20ms for any write operation on my machine, even using emulated serial ports**. Of course threaded writes don't make that latency magically disappear, but they can shunt it off to one of the 3+ cores Arma never uses and let Arma get on with whatever stuff it needs to do in the meantime. Because Bohemia is working with a very old codebase that was absolutely not written with maintainability and performance in mind, Arma is single-threaded. SQF manages to fake the ability to run multiple scripts at once by using a basic scheduler that begins execution of a "thread", runs it until it passes some predefined allotment of time, and then moves on to the next "thread" if it isn't terribly behind and needs to yield its CPU time to other things. This tends to work well enough with how fast modern CPUs are, but a very important limitation is that the SQF VM **cannot make an extension yield its time**. When `callExtension` is run, Arma has to stop pretty much everything it's doing until the extension returns, which makes waiting around for a write to finish for 20+ms a very bad idea. If you're lucky enough for your game to be running at 60 FPS, that means a new frame comes through every 16.6ms - that's right, a single write to a serial port takes longer than running physics simulations and rendering an entire frame by almost 25%. So please, turn on threaded writes, and if that's not good enough, consider something other than the terribly dated technology that is serial communications.

## Static Commands

These commands must be called with the format `"ArmaCOM" callExtension ["name of the communication method", ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as static methods on the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `create` | `portName`: `string` | A success or failure message | `"ArmaCOM" callExtension ["Serial", ["create", portName]];` | Creates an instance of this communication method and returns a UUID representing it. This command does not attempt to connect to the given port; the `connect` command must be called separately. Note that `portName` should be the name of the port (e.g. `COM1`), not its file (e.g. `\\.\\\\COM1`). |
| `listBaudRates` | None | A list of currently available baud rates in the format [[index:int , baudRate: int], ...] | `"ArmaCOM" callExtension ["Serial", ["listBaudRates"]];` | This command simply enumerates the baud rates known to the extension; listed baud rates may not be compatible with the specific serial device. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
| `listDataBits` | None | A list of currently available data bits in the format [[index: int, dataBits: string], ...] | `"ArmaCOM" callExtension ["Serial", ["listDataBits"]];` | This command simply enumerates the data bits known to the extension; listed data bits may not be compatible with the specific serial device. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
| `listInstances` | None | A list of instances of this communication method in the format [[UUID: string, portName: string], ...] | `"ArmaCOM" callExtension ["Serial", ["listInstances"]];` | Lists extant instances of the serial communication method and their UUIDs so users have a hope of recovering their instance if they lose the UUID. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
| `listParities` | None | A list of currently available parities in the format [[index: int, parity: string], ...] | `"ArmaCOM" callExtension ["Serial", ["listParities"]];` | This command simply enumerates the parities known to the extension; listed parities may not be compatible with the specific serial device. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
| `listPorts` | None | A list of currently available COM (serial) ports in the format [[portName: string, portDriver: string], ...] | `"ArmaCOM" callExtension ["Serial", ["listPorts"]];` | Queries the currently available DOS COM ports using the Windows function `QueryDosDevice` from COM0 to COM254 inclusive. This method is marginally more computationally expensive than checking the registry, but the registry may be out of date, so this command is guaranteed to return the most up-to-date data. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
| `listStopBits` | None | A list of currently available stop bits in the format [[index: int, stopBits: string], ...] | `"ArmaCOM" callExtension ["Serial", ["listStopBits"]];` | This command simply enumerates the stop bits known to the extension; listed stop bits may not be compatible with the specific serial device. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
## Instance Commands

These commands must be called with the format `"ArmaCOM" callExtension [myInstanceUUID, ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as instance methods on your instance of the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `callbackOnChar` | `charToLookFor`: `char` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnChar", charToLookFor]];` | Makes the extension send data read from this port back to Arma when `charToLookFor`, specified as a `char`, is read. When the character is read, all data up to and **excluding** that character is sent back to Arma via the callback. |
| `callbackOnCharCode` | `charCodeToLookFor`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnCharCode", charCodeToLookFor]];` | Makes the extension send data read from this port back to Arma when the character described by `charCodeToLookFor`, specified as an ASCII char code e.g. `65` for "A", is read. When the character is read, all data read since the last callback, up to and **excluding** that character, is sent back to Arma via the callback. |
| `callbackOnLength` | `lengthToStopAt`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnLength", lengthToStopAt]];` | Makes the extension send data read from this port back to Arma when the total amount of data read reaches `lengthToStopAt` characters long. When the target amount of data is read, all data read since the last callback is sent back to Arma via the callback. |
| `connect` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["connect"]];` | Attempts to connect to the port described by this instance. |
| `disconnect` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["disconnect"]];` | Attempts to disconnect from the port described by this instance. If threaded writes are enabled, the extension will attempt to flush the remaining data **synchronously** before disconnecting. |
| `enableThreadedWrites` | None | Success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["enableThreadedWrites"]];` | Attempts to begin using a separate thread for writing. May dramatically reduce the time `write` calls take to return to SQF. See the README for more information. |
| `getBaudRateIndex` | None | The index of the currently set baud rate | `"ArmaCOM" callExtension [myInstanceUUID, ["getBaudRateIndex"]];` | Gets the index of the currently set baud rate |
| `getBaudRateValue` | None | The currently set baud rate | `"ArmaCOM" callExtension [myInstanceUUID, ["getBaudRateValue"]];` | Gets the currently set baud rate |
| `getDataBitsIndex` | None | The index of the currently set data bits | `"ArmaCOM" callExtension [myInstanceUUID, ["getDataBitsIndex"]];` | Gets the index of the currently set data bits |
| `getDataBitsValue` | None | The currently set data bits | `"ArmaCOM" callExtension [myInstanceUUID, ["getDataBitsValue"]];` | Gets the currently set data bits |
| `getEofChar` | None | The current ASCII charcode of eofChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getEofChar"]];` | The character used to signal the end of data. Default: `0`. |
| `getErrorChar` | None | The current ASCII charcode of errorChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getErrorChar"]];` | Default: `0`. |
| `getEvtChar` | None | The current ASCII charcode of evtChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getEvtChar"]];` | The character used to signal an event. Default: `0`. |
| `getFAbortOnError` | None | `true` or `false` based on the currently set `fAbortOnError` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFAbortOnError"]];` | If `true`, the driver terminates all read and write operations with an error status if an error occurs. The driver will not accept any further communications until the extension clears the error (currently not implemented). Default: `false`. |
| `getFDsrSensitivity` | None | `true` or `false` based on the currently set `fDsrSensitivity` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFDsrSensitivity"]];` | If `true`, the driver is sensitive to the state of the DSR signal - all recieved bytes will be ignored unless the DSR input line is high. Default: `false`. |
| `getFDtrControl` | None | `0`, `1`, or `2` based on the currently set `fDtrControl` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFDtrControl"]];` | If `0`, the Data-Terminal-Ready line is disabled. If `1`, the DTR line is enabled and left on. If `2`, it is an error to adjust the DTR line. Default: `1`. |
| `getFErrorChar` | None | `true` or `false` based on the currently set `fErrorChar` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFErrorChar"]];` | If `true` and `fParity` is true, bytes received with parity errors are replaced with `ErrorChar`. Defualt: `false`. |
| `getFInX` | None | `true` or `false` based on the currently set `fInX` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFInX"]];` | If `true`, the `XoffChar` character is sent when the input buffer comes within `XoffLim` bytes of being full, and the `XonChar` character is sent when the input buffer comes within `XonLim` bytes of being empty. Defualt: `false`. |
| `getFNull` | None | `true` or `false` based on the currently set `fNull` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFNull"]];` | If `true`, null bytes are discarded when received. Defualt: `false`. |
| `getFOutX` | None | `true` or `false` based on the currently set `fOutX` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFOutX"]];` | If `true`, transmission stops when the `XoffChar` character is received and starts again when the `XonChar` character is received. Default: `false`. |
| `getFOutxCtsFlow` | None | `true` or `false` based on the currently set `fOutxCtsFlow` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFOutxCtsFlow"]];` | If `true`, the Clear-To-Send signal is monitored, and when the CTS is turned off, output is suspended until the CTS is sent again. Default: `false`. |
| `getFOutxDsrFlow` | None | `true` or `false` based on the currently set `fOutxDsrFlow` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFOutxDsrFlow"]];` | If `true`, the Data-Set-Ready signal is monitored, and when the DSR is turned off, output is suspended until the DSR is sent again. Default: `false`. |
| `getFParity` | None | `true` or `false` based on the currently set `fParity` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFParity"]];` | If `true`, parity checking is performed. Default: `false`. |
| `getFRtsControl` | None | `0`, `1`, `2`, or `3` based on the currently set `fRtsControl` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFRtsControl"]];` | If `0`, the Request-To-Send line is disabled. If `1`, the RTS line is opened and left on. If `2`, RTS handshaking is enabled - the drived raises the RTS line when the input buffer is less than one half full and lowers the RTS line when the buffer is more than three quarters full, and it is an error to adjust the RTS line. If `3`, the RTS line will be high if bytes are available for transmission, and after all buffered bytes have been sent, the RTS line will be low. Default: `1`. |
| `getFTXContinueOnXoff` | None | `true` or `false` based on the currently set `fTXContinueOnXoff` | `"ArmaCOM" callExtension [myInstanceUUID, ["getFTXContinueOnXoff"]];` | If `true`, transmission continues after the input buffer has come within `XoffLim` bytes of being full and the driver has transmitted the `XoffChar` character to stop receiving bytes. If `false`, transmission does not continue until the input buffer is within `XonLim` bytes of being empty and the driver has transmitted the `XonChar` character to resume reception. Default: `false`. |
| `getParityIndex` | None | The index of the currently set parity bit(s) | `"ArmaCOM" callExtension [myInstanceUUID, ["getParityIndex"]];` | Gets the index of the currently set parity bit(s) |
| `getParityValue` | None | The currently set parity bit(s) | `"ArmaCOM" callExtension [myInstanceUUID, ["getParityValue"]];` | Gets the currently set parity bit(s) |
| `getStopBitsIndex` | None | The index of the currently set stop bit(s) | `"ArmaCOM" callExtension [myInstanceUUID, ["getStopBitsIndex"]];` | Gets the index of the currently set stop bit(s) |
| `getStopBitsValue` | None | The currently set stop bit(s) | `"ArmaCOM" callExtension [myInstanceUUID, ["getStopBitsValue"]];` | Gets the currently set stop bit(s) |
| `getXoffChar` | None | The current ASCII charcode of XoffChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getXoffChar"]];` | Default: `19` (device control 3). |
| `getXoffLim` | None | The current XoffChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getXoffLim"]];` | See `fInX`, `fRtsControl`, and `fDtrControl`. Default: `512`. |
| `getXonChar` | None | The current ASCII charcode of XonChar | `"ArmaCOM" callExtension [myInstanceUUID, ["getXonChar"]];` | Default: `17` (device control 1). |
| `getXonLim` | None | The current XonLim | `"ArmaCOM" callExtension [myInstanceUUID, ["getXonLim"]];` | See `fInX`, `fRtsControl`, and `fDtrControl`. Default: `2048`. |
| `isUsingWriteThread` | None | `true` or `false` based on whether this serial port is using a thread for writes | `"ArmaCOM" callExtension [myInstanceUUID, ["isUsingWriteThread"]];` | May dramatically improve performance. See the main header of this communication method for more information. |
| `setBaudRate` | `baudRateIndex`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setBaudRate", baudRateIndex]];` | Sets the baud rate. `baudRateIndex` is the index of the desired baud rate (from `listBaudRates`). |
| `setDataBits` | `dataBitsIndex`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setDataBits", dataBitsIndex]];` | Sets the data bits. `dataBitsIndex` is the index of the desired baud rate (from `listDataBits`). |
| `setEofChar` | `EofChar`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setEofChar", EofChar]];` | Sets EofChar. EofChar is an integer ASCII code, e.g. `65` for "A". The character used to signal the end of data. Default: `0`. |
| `setErrorChar` | `ErrorChar`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setErrorChar", ErrorChar]];` | Sets ErrorChar. ErrorChar is an integer ASCII code, e.g. `65` for "A". Default: `0`. |
| `setEvtChar` | `EvtChar`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setEvtChar", EvtChar]];` | Sets EvtChar. EvtChar is an integer ASCII code, e.g. `65` for "A". The character used to signal an event. Default: `0`. |
| `setFAbortOnError` | `fAbortOnError`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFAbortOnError", fAbortOnError]];` | Sets fAbortOnError. If `true`, the driver terminates all read and write operations with an error status if an error occurs. The driver will not accept any further communications until the extension clears the error (currently not implemented). Default: `false`. |
| `setFDsrSensitivity` | `fDsrSensitivity`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFDsrSensitivity", fDsrSensitivity]];` | Sets fDsrSensitivity. If `true`, the driver is sensitive to the state of the DSR signal - all recieved bytes will be ignored unless the DSR input line is high. Default: `false`. |
| `setFDtrControl` | `fDtsControl`: `0 \| 1 \| 2` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFDtrControl", fDtsControl]];` | Sets fDtrControl. If `0`, the Data-Terminal-Ready line is disabled. If `1`, the DTR line is enabled and left on. If `2`, it is an error to adjust the DTR line. Default: `1`. |
| `setFErrorChar` | `fErrorChar`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFErrorChar", fErrorChar]];` | Sets fErrorChar. If `true` and `fParity` is true, bytes received with parity errors are replaced with `ErrorChar`. Defualt: `false`. |
| `setFInX` | `fInX`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFInX", fInX]];` | Sets fInX. If `true`, the `XoffChar` character is sent when the input buffer comes within `XoffLim` bytes of being full, and the `XonChar` character is sent when the input buffer comes within `XonLim` bytes of being empty. Defualt: `false`. |
| `setFNull` | `fNull`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFNull", fNull]];` | Sets fNull. If `true`, null bytes are discarded when received. Defualt: `false. |
| `setFOutX` | `fOutX`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFOutX", fOutX]];` | Sets fOutX. If `true`, transmission stops when the `XoffChar` character is received and starts again when the `XonChar` character is received. Default: `false`. |
| `setFOutxCtsFlow` | `fOutxCtsFlow`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFOutxCtsFlow", fOutxCtsFlow]];` | Sets `fOutxCtsFlow`. If `true`, the Clear-To-Send signal is monitored, and when the CTS is turned off, output is suspended until the CTS is sent again. Default: `false`. |
| `setFOutxDsrFlow` | `fOutxDsrFlow`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFOutxDsrFlow", fOutxDsrFlow]];` | Sets fOutxDsrFlow. If `true`, the Data-Set-Ready signal is monitored, and when the DSR is turned off, output is suspended until the DSR is sent again. Default: `false`. |
| `setFParity` | `fParity`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFParity", fParity]];` | Sets `fParity`. If `true`, parity checking is performed. Default: `false`. |
| `setFRtsControl` | `fRtsControl`: `0 \| 1 \| 2 \| 3` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFRtsControl", fRtsControl]];` | Sets fRtsControl. If `0`, the Request-To-Send line is disabled. If `1`, the RTS line is opened and left on. If `2`, RTS handshaking is enabled - the drived raises the RTS line when the input buffer is less than one half full and lowers the RTS line when the buffer is more than three quarters full, and it is an error to adjust the RTS line. If `3`, the RTS line will be high if bytes are available for transmission, and after all buffered bytes have been sent, the RTS line will be low. Default: `1`. |
| `setFTXContinueOnXoff` | `fTXContinueOnXoff`: `bool` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setFTXContinueOnXoff", fTXContinueOnXoff]];` | Sets fTXContinueOnXoff. If `true`, transmission continues after the input buffer has come within `XoffLim` bytes of being full and the driver has transmitted the `XoffChar` character to stop receiving bytes. If `false`, transmission does not continue until the input buffer is within `XonLim` bytes of being empty and the driver has transmitted the `XonChar` character to resume reception. Default: `false`. |
| `setParity` | `parityIndex`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setParity", parityIndex]];` | Sets the parity. `parityIndex` is the index of the desired parity (from `listParities`). |
| `setStopBits` | `stopBitsIndex`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setStopBits", stopBitsIndex]];` | Sets the stop bit(s). `stopBitsIndex` is the index of the desired stop bit(s) (from `listStopBits`). |
| `setXoffChar` | `XoffChar`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setXoffChar", XoffChar]];` | Sets XoffChar. XoffChar is an integer ASCII code, e.g. `65` for "A". Default: `19` (device control 3). |
| `setXoffLim` | `XoffLim`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setXoffLim", XoffLim]];` | Sets XoffLim. See `fInX`, `fRtsControl`, and `fDtrControl`. Default: `512`. |
| `setXonChar` | `XonChar`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setXonChar", XonChar]];` | Sets XonChar. XonChar is an integer ASCII code, e.g. `65` for "A". Default: `17` (device control 1). |
| `setXonLim` | `XonLim`: `int` | A failure or success message | `"ArmaCOM" callExtension [myInstanceUUID, ["setXonLim", XonLim]];` | Sets XonLim. See `fInX`, `fRtsControl`, and `fDtrControl`. Default: `2048`. |
| `write` | `data`: `string` | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["write", data]];` | Attempts to either write the data to the serial port if threaded writes are disabled, or queue the data to be written if threaded writes are enabled. If threaded writes are enabled, this command's return value does not say whether the data has successfully been *written*, only that it has been *queued*. |

# Communication Method: TCPClient

This communication method is an interface for a TCP client. It is capable of asynchronous operations and should be able to connect given any valid IP endpoint locator, including domains (e.g. "google.com", "github.com/googleben") and IP addresses (e.g. "127.0.0.1", "1.1.1.1"). Synchronous versions of operations are included, but I strongly recommend using the asynchronous versions unless you really need the output without getting it from a callback.

## Static Commands

These commands must be called with the format `"ArmaCOM" callExtension ["name of the communication method", ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as static methods on the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `create` | `endpoint`: `string`, `port`: `string` | A success or failure message | `"ArmaCOM" callExtension ["TCPClient", ["create", endpoint, port]];` | Creates an instance of this communication method and returns a UUID representing it. This command does not attempt to connect to the given endpoint; the `connect` command must be called separately. `endpoint` should be a valid, resolvable IP endpoint, consisting of first either a domain or an IP. Examples of valid endpoints: `127.0.0.1`, `example.com` |
| `listInstances` | None | A list of instances of this communication method in the format [[UUID: string, endpoint: string], ...] | `"ArmaCOM" callExtension ["TCPClient", ["listInstances"]];` | Lists extant instances of the tcpClient communication method and their UUIDs so users have a hope of recovering their instance if they lose the UUID. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
## Instance Commands

These commands must be called with the format `"ArmaCOM" callExtension [myInstanceUUID, ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as instance methods on your instance of the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `callbackOnChar` | `charToLookFor`: `char` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnChar", charToLookFor]];` | Makes the extension send data read from this port back to Arma when `charToLookFor`, specified as a `char`, is read. When the character is read, all data up to and **excluding** that character is sent back to Arma via the callback. |
| `callbackOnCharCode` | `charCodeToLookFor`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnCharCode", charCodeToLookFor]];` | Makes the extension send data read from this port back to Arma when the character described by `charCodeToLookFor`, specified as an ASCII char code e.g. `65` for "A", is read. When the character is read, all data read since the last callback, up to and **excluding** that character, is sent back to Arma via the callback. |
| `callbackOnLength` | `lengthToStopAt`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnLength", lengthToStopAt]];` | Makes the extension send data read from this port back to Arma when the total amount of data read reaches `lengthToStopAt` characters long. When the target amount of data is read, all data read since the last callback is sent back to Arma via the callback. |
| `connect` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["connect"]];` | Attempts to connect to the endpoint described by this instance. Warning: This command will not return until either a connection is made or the socket times out. This will probably take a long time (at least 2 seconds) to happen, and the SQF VM will be stalled until that happens. |
| `connectAsync` | None | None | `"ArmaCOM" callExtension [myInstanceUUID, ["connectAsync"]];` | Attempts to connect to the endpoint described by this instance asynchronously. On success or failure, the extension will call the callback with the message being the instance UUID and the data being an array with a success or failure message. |
| `disconnect` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["disconnect"]];` | Attempts to disconnect from the TCP server described by this instance. Any queued asynchronous operations will be canceled. |
| `write` | `message`: `string` | Success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["write", message]];` | Attempts to send `message` |

# Communication Method: TCPServer

This communication method is an interface for a TCP server. It can asynchronously listen for incoming connections on a provided port and return TCPServerConnections representing active connections.

## Static Commands

These commands must be called with the format `"ArmaCOM" callExtension ["name of the communication method", ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as static methods on the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `create` | `port`: `int` | A success or failure message | `"ArmaCOM" callExtension ["TCPServer", ["create", port]];` | Creates an instance of this communication method and returns a UUID representing it. This command does not attempt to listen for connections; you must initiate that separately. |
| `listInstances` | None | A list of instances of this communication method in the format [[UUID: string, port: string], ...] | `"ArmaCOM" callExtension ["TCPServer", ["listInstances"]];` | Lists extant instances of the TCPServer communication method and their UUIDs so users have a hope of recovering their instance if they lose the UUID. Remember to use `parseSimpleArray` since extensions can only communicate using strings. |
## Instance Commands

These commands must be called with the format `"ArmaCOM" callExtension [myInstanceUUID, ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as instance methods on your instance of the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `disconnectAll` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["disconnectAll"]];` | Attempts to disconnect and destroy all existing connections to this server. All clients must be disconnected before destroying a server, so call this function before attempting to destroy a TCPServer if you're not sure if there's still connections. |
| `listen` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["listen"]];` | Attempts to start listening for new TCP connections on this server's port. The listening process is asynchronous, and connections will be reported via callback, with the function being "new_tcp_connection", and the args taking this form: `[serverID: string, newConnectionID: string]` If the attempt fails at a later stage during the async pipeline, the failure will be reported along with an error message, with the function being "FAILURE" and the args taking this form: `[serverID: string, message: string]` As mentioned earlier, connections are of the communication method TCPServerConnection. |
| `stopListening` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["stopListening"]];` | Stops listening for new connections. |

# Communication Method: TCPServerConnection

This communication method is used for TCP connections to a TCPServer communication method. This comm method cannot be directly created; it is only created when a remote client connects to a TCPServer.

## Static Commands

These commands must be called with the format `"ArmaCOM" callExtension ["name of the communication method", ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as static methods on the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
## Instance Commands

These commands must be called with the format `"ArmaCOM" callExtension [myInstanceUUID, ["command name", [arg1, arg2, ...]]`.
Those familiar with object-oriented programming should think of them as instance methods on your instance of the communication method's class.

| Name | Arguments | Return Value | SQF Example | Comments |
| ---  | ---       | ---          | ---         | ---      |
| `callbackOnChar` | `charToLookFor`: `char` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnChar", charToLookFor]];` | Makes the extension send data read from this port back to Arma when `charToLookFor`, specified as a `char`, is read. When the character is read, all data up to and **excluding** that character is sent back to Arma via the callback. |
| `callbackOnCharCode` | `charCodeToLookFor`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnCharCode", charCodeToLookFor]];` | Makes the extension send data read from this port back to Arma when the character described by `charCodeToLookFor`, specified as an ASCII char code e.g. `65` for "A", is read. When the character is read, all data read since the last callback, up to and **excluding** that character, is sent back to Arma via the callback. |
| `callbackOnLength` | `lengthToStopAt`: `int` | None | `"ArmaCOM" callExtension [myInstanceUUID, ["callbackOnLength", lengthToStopAt]];` | Makes the extension send data read from this port back to Arma when the total amount of data read reaches `lengthToStopAt` characters long. When the target amount of data is read, all data read since the last callback is sent back to Arma via the callback. |
| `disconnect` | None | A success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["disconnect"]];` | Attempts to disconnect from the remote client. Any queued asynchronous operations will be canceled. |
| `isIPv6` | None | Whether or not this connection is IPv6 | `"ArmaCOM" callExtension [myInstanceUUID, ["isIPv6"]];` | Returns `true` if this connection is over IPv6, and `false` otherwise |
| `write` | None | The remote endpoint this connection is to | `"ArmaCOM" callExtension [myInstanceUUID, ["write"]];` | Returns the name of the remote endpoint this connection is to as described by the underlying socket. The returned value will be the endpoint's name and the (remote) port, separated by a colon, e.g. `127.0.0.1:8080`. |
| `write` | `message`: `string` | Success or failure message | `"ArmaCOM" callExtension [myInstanceUUID, ["write", message]];` | Attempts to send `message` |
